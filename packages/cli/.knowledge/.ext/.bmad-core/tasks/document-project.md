<!-- Powered by BMAD™ Core -->

# 为现有项目生成文档

## 目的

为现有项目生成全面的文档，专门为AI开发代理优化。这个任务创建结构化的参考资料，让AI代理能够理解项目context、约定和模式，从而有效地为任何代码库做出贡献。

## 任务说明

### 1. 初始项目分析

**关键：** 首先检查context中是否存在PRD或需求文档。如果有，用它来专注于相关领域的文档工作。

**如果有PRD**：

- 看看PRD了解计划中的enhancement/功能
- 识别哪些模块、服务或领域会受到影响
- 只专注于这些相关领域的文档
- 跳过代码库中不相关的部分，保持文档精简

**如果没有PRD**：
询问用户：

"我注意到你没有提供PRD或需求文档。为了创建更有针对性和有用的文档，我建议以下选项之一：

1. **先创建PRD** - 你想让我在文档化之前帮你创建一个brownfield PRD吗？这有助于专注于相关领域的文档。

2. **提供现有需求** - 你有需求文档、epic或功能描述可以分享吗？

3. **描述重点** - 你能简单描述一下你计划做什么enhancement或功能吗？比如：
   - '给用户服务添加支付处理'
   - '重构认证模块'
   - '集成新的第三方API'

4. **全部文档化** - 或者我应该对整个代码库进行全面的文档化？(注意：对于大型项目可能会产生过多的文档)

请告诉我你的偏好，或者如果你愿意，我可以进行完整的文档化。"

根据他们的回复：

- 如果他们选择选项1-3：用那个context来专注于文档
- 如果他们选择选项4或拒绝：继续下面的全面分析

开始对现有项目进行分析。使用可用工具来：

1. **项目结构发现**：检查根目录结构，识别主要文件夹，了解整体组织
2. **技术栈识别**：找找package.json、requirements.txt、Cargo.toml、pom.xml等来识别语言、框架和依赖
3. **构建系统分析**：找到构建脚本、CI/CD配置和开发命令
4. **现有文档审查**：检查README文件、docs文件夹和任何现有文档
5. **代码模式分析**：采样关键文件来理解编码模式、命名约定和架构方法

问问用户这些引导问题来更好地理解他们的需求：

- 这个项目的主要目的是什么？
- 代码库中是否有特别复杂或对代理理解很重要的特定领域？
- 你期望AI代理在这个项目上执行什么类型的任务？(比如，bug修复、功能添加、重构、测试)
- 你有任何偏好的现有文档标准或格式吗？
- 文档应该针对什么级别的技术细节？(初级开发者、高级开发者、混合团队)
- 你计划有什么特定的功能或enhancement吗？(这有助于专注于文档)

### 2. 深度代码库分析

关键：在生成文档之前，对现有代码库进行广泛分析：

1. **探索关键领域**：
   - 入口点(主文件、index文件、应用初始化器)
   - 配置文件和环境设置
   - 包依赖和版本
   - 构建和部署配置
   - 测试套件和覆盖率

2. **询问澄清问题**：
   - "我看到你在用[技术X]。有什么自定义模式或约定我应该文档化吗？"
   - "这个系统中最关键/复杂的部分是什么，开发者经常遇到困难？"
   - "有什么未文档化的'部落知识'领域我应该捕获吗？"
   - "我应该文档化什么技术债务或已知问题？"
   - "代码库的哪些部分变化最频繁？"

3. **映射现实**：
   - 识别实际使用的模式(不是理论最佳实践)
   - 找到关键业务逻辑在哪
   - 定位集成点和外部依赖
   - 文档化变通方案和技术债务
   - 注意与标准模式不同的领域

**如果提供了PRD**：还要分析enhancement需要什么改变

### 3. 核心文档生成

[[LLM: 生成一个全面的BROWNFIELD架构文档，反映代码库的实际状态。

**关键**：这不是一个理想化的架构文档。文档化实际存在的内容，包括：

- 技术债务和变通方案
- 不同部分之间的不一致模式
- 无法更改的遗留代码
- 集成约束
- 性能瓶颈

**文档结构**：

# [项目名称] Brownfield架构文档

## 介绍

这个文档捕获了[项目名称]代码库的当前状态，包括技术债务、变通方案和现实世界的模式。它作为AI代理进行enhancement工作的参考。

### 文档范围

[如果提供了PRD："专注于相关领域：{enhancement描述}"]
[如果没有PRD："整个系统的全面文档"]

### 变更日志

| 日期   | 版本 | 描述               | 作者     |
| ------ | ---- | ------------------ | -------- |
| [日期] | 1.0  | 初始brownfield分析 | [分析师] |

## 快速参考 - 关键文件和入口点

### 理解系统的关键文件

- **主入口**：`src/index.js`(或实际入口点)
- **配置**：`config/app.config.js`、`.env.example`
- **核心业务逻辑**：`src/services/`、`src/domain/`
- **API定义**：`src/routes/`或链接到OpenAPI规范
- **数据库模型**：`src/models/`或链接到模式文件
- **关键算法**：[列出有复杂逻辑的特定文件]

### 如果提供了PRD - enhancement影响领域

[突出显示哪些文件/模块会受到计划enhancement的影响]

## 高级架构

### 技术总结

### 实际技术栈(来自package.json/requirements.txt)

| 类别   | 技术       | 版本   | 备注             |
| ------ | ---------- | ------ | ---------------- |
| 运行时 | Node.js    | 16.x   | [任何约束]       |
| 框架   | Express    | 4.18.2 | [自定义中间件？] |
| 数据库 | PostgreSQL | 13     | [连接池设置]     |

等等...

### 仓库结构现实检查

- 类型：[Monorepo/Polyrepo/Hybrid]
- 包管理器：[npm/yarn/pnpm]
- 值得注意：[任何不寻常的结构决策]

## 源码树和模块组织

### 项目结构(实际)

```text
project-root/
├── src/
│   ├── controllers/     # HTTP请求处理器
│   ├── services/        # 业务逻辑(注意：用户和支付服务之间的模式不一致)
│   ├── models/          # 数据库模型(Sequelize)
│   ├── utils/           # 混合包 - 需要重构
│   └── legacy/          # 不要修改 - 旧支付系统仍在使用
├── tests/               # Jest测试(60%覆盖率)
├── scripts/             # 构建和部署脚本
└── config/              # 环境配置
```

### 关键模块及其用途

- **用户管理**：`src/services/userService.js` - 处理所有用户操作
- **认证**：`src/middleware/auth.js` - 基于JWT，自定义实现
- **支付处理**：`src/legacy/payment.js` - 关键：不要重构，紧密耦合
- **[列出其他关键模块及其实际文件]**

## 数据模型和API

### 数据模型

不要重复，引用实际模型文件：

- **用户模型**：参见`src/models/User.js`
- **订单模型**：参见`src/models/Order.js`
- **相关类型**：TypeScript定义在`src/types/`

### API规范

- **OpenAPI规范**：`docs/api/openapi.yaml`(如果存在)
- **Postman集合**：`docs/api/postman-collection.json`
- **手动端点**：[列出发现的任何未文档化端点]

## 技术债务和已知问题

### 关键技术债务

1. **支付服务**：`src/legacy/payment.js`中的遗留代码 - 紧密耦合，没有测试
2. **用户服务**：与其他服务不同的模式，用回调而不是promises
3. **数据库迁移**：手动跟踪，没有适当的迁移工具
4. **[其他重大债务]**

### 变通方案和陷阱

- **环境变量**：即使对于staging也必须设置`NODE_ENV=production`(历史原因)
- **数据库连接**：连接池硬编码为10，改了会破坏支付服务
- **[开发者需要知道的其他变通方案]**

## 集成点和外部依赖

### 外部服务

| 服务     | 用途 | 集成类型 | 关键文件                       |
| -------- | ---- | -------- | ------------------------------ |
| Stripe   | 支付 | REST API | `src/integrations/stripe/`     |
| SendGrid | 邮件 | SDK      | `src/services/emailService.js` |

等等...

### 内部集成点

- **前端通信**：端口3000上的REST API，期望特定头部
- **后台作业**：Redis队列，参见`src/workers/`
- **[其他集成]**

## 开发和部署

### 本地开发设置

1. 实际有效的步骤(不是理想步骤)
2. 设置的已知问题
3. 必需的环境变量(参见`.env.example`)

### 构建和部署过程

- **构建命令**：`npm run build`(webpack配置在`webpack.config.js`)
- **部署**：通过`scripts/deploy.sh`手动部署
- **环境**：Dev、Staging、Prod(参见`config/environments/`)

## 测试现实

### 当前测试覆盖率

- 单元测试：60%覆盖率(Jest)
- 集成测试：最少，在`tests/integration/`
- E2E测试：无
- 手动测试：主要QA方法

### 运行测试

```bash
npm test           # 运行单元测试
npm run test:integration  # 运行集成测试(需要本地DB)
```

## 如果提供了enhancement PRD - 影响分析

### 需要修改的文件

基于enhancement需求，这些文件会受到影响：

- `src/services/userService.js` - 添加新用户字段
- `src/models/User.js` - 更新模式
- `src/routes/userRoutes.js` - 新端点
- [等等...]

### 需要的新文件/模块

- `src/services/newFeatureService.js` - 新业务逻辑
- `src/models/NewFeature.js` - 新数据模型
- [等等...]

### 集成考虑

- 需要与现有认证中间件集成
- 必须遵循`src/utils/responseFormatter.js`中的现有响应格式
- [其他集成点]

## 附录 - 有用的命令和脚本

### 常用命令

```bash
npm run dev         # 启动开发服务器
npm run build       # 生产构建
npm run migrate     # 运行数据库迁移
npm run seed        # 种子测试数据
```

### 调试和故障排除

- **日志**：检查`logs/app.log`获取应用日志
- **调试模式**：设置`DEBUG=app:*`进行详细日志记录
- **常见问题**：参见`docs/troubleshooting.md`]]

### 4. 文档交付

1. **在Web UI中(Gemini、ChatGPT、Claude)**：
   - 在一个响应中呈现整个文档(如果太长可以分多个)
   - 告诉用户复制并保存为`docs/brownfield-architecture.md`或`docs/project-architecture.md`
   - 提到如果需要可以在IDE中稍后分片

2. **在IDE环境中**：
   - 创建文档为`docs/brownfield-architecture.md`
   - 告知用户这个单一文档包含所有架构信息
   - 如果需要可以使用PO代理稍后分片

文档应该足够全面，让未来的代理能够理解：

- 系统的实际状态(不是理想化的)
- 在哪里找到关键文件和逻辑
- 存在什么技术债务
- 必须尊重什么约束
- 如果提供了PRD：enhancement需要什么改变]]

### 5. 质量保证

关键：在最终确定文档之前：

1. **准确性检查**：验证所有技术细节与实际代码库匹配
2. **完整性审查**：确保所有主要系统组件都已文档化
3. **重点验证**：如果用户提供了范围，验证相关领域得到强调
4. **清晰度评估**：检查解释对AI代理是否清晰
5. **导航**：确保文档有清晰的部分结构便于参考

在主要部分之后应用高级引导任务，根据用户反馈进行完善。

## 成功标准

- 创建了单一全面的brownfield架构文档
- 文档反映现实，包括技术债务和变通方案
- 关键文件和模块引用实际路径
- 模型/API引用源文件而不是重复内容
- 如果提供了PRD：清晰的影响分析显示需要什么改变
- 文档使AI代理能够导航和理解实际代码库
- 技术约束和"陷阱"得到清晰文档化

## 注意事项

- 这个任务创建一个文档来捕获系统的真实状态
- 尽可能引用实际文件而不是重复内容
- 诚实地文档化技术债务、变通方案和约束
- 对于有PRD的brownfield项目：提供清晰的enhancement影响分析
- 目标是为做实际工作的AI代理提供实用的文档
